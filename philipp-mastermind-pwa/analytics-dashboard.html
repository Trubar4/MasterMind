<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mastermind Analytics Dashboard</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
	<!-- Google API Client Library -->
	<script src="https://apis.google.com/js/api.js"></script>
	<!-- Google Identity Services -->
	<script src="https://accounts.google.com/gsi/client"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #ddd;
    }
    .header h1 {
      margin: 0;
      color: #333;
    }
    .date-range {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(500px, 1fr));
      gap: 20px;
    }
    .card {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      padding: 15px;
    }
    .card-header {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 15px;
      color: #333;
    }
    .stat-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }
    .stat-card {
      background: #f9f9f9;
      border-radius: 6px;
      padding: 15px;
      text-align: center;
    }
    .stat-value {
      font-size: 28px;
      font-weight: bold;
      color: #6200EE;
      margin: 5px 0;
    }
    .stat-label {
      font-size: 14px;
      color: #666;
    }
    .chart-container {
      position: relative;
      height: 300px;
      width: 100%;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    table th, table td {
      padding: 10px;
      text-align: left;
      border-bottom: 1px solid #eee;
    }
    table th {
      background-color: #f9f9f9;
      font-weight: bold;
    }
    .color-sample {
      display: inline-block;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      margin-right: 5px;
      vertical-align: middle;
    }
    .controls {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
    }
    button {
      background-color: #6200EE;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #5000c9;
    }
    .filter {
      background-color: white;
      padding: 8px;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    #auth-button {
      margin-bottom: 20px;
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: rgba(255, 255, 255, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #6200EE;
      border-radius: 50%;
      animation: spin 2s linear infinite;
    }
    .error-message {
      background-color: #ffebee;
      color: #c62828;
      padding: 10px;
      border-radius: 4px;
      margin-bottom: 10px;
      display: none;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .hidden {
      display: none !important;
    }
    .status-message {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      background-color: #e8f5e9;
      color: #2e7d32;
    }
	#auth-container {
	  margin-bottom: 20px;
	}
	#sign-in-button {
	  background-color: #4285F4;
	  color: white;
	  border: none;
	  padding: 10px 16px;
	  border-radius: 4px;
	  cursor: pointer;
	  font-weight: bold;
	}
	#sign-in-button:hover {
	  background-color: #3367D6;
	}
	#sign-out-button {
	  margin-left: 10px;
	  background-color: #757575;
	}
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>Philipp's Mastermind Analytics</h1>
      <div id="auth-container">
		  <button id="sign-in-button" class="hidden">Sign In with Google</button>
		  <button id="sign-out-button" class="hidden">Sign Out</button>
      </div>
    </div>

    <div id="error-message" class="error-message"></div>
    <div id="status-message" class="status-message hidden"></div>

    <div id="dashboard-content" class="hidden">
      <div class="date-range">
        <label for="start-date">From:</label>
        <input type="date" id="start-date">
        <label for="end-date">To:</label>
        <input type="date" id="end-date">
        <button id="apply-date">Apply</button>
      </div>

      <div class="controls">
        <div>
          <button id="refresh-data">Refresh Data</button>
          <button id="export-data">Export CSV</button>
        </div>
        <div>
          <select id="filter-mode" class="filter">
            <option value="all">All Game Modes</option>
            <option value="both">2 Player</option>
            <option value="codemakerMode">Computer as Breaker</option>
            <option value="codebreakerMode">Computer as Maker</option>
          </select>
          <select id="filter-code-length" class="filter">
            <option value="all">All Code Lengths</option>
            <option value="4">4 Circles</option>
            <option value="5">5 Circles</option>
          </select>
        </div>
      </div>

      <div class="dashboard">
        <!-- Overview Stats -->
        <div class="card">
          <div class="card-header">Overview</div>
          <div class="stat-container">
            <div class="stat-card">
              <div class="stat-value" id="total-games">0</div>
              <div class="stat-label">Games Played</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="total-users">0</div>
              <div class="stat-label">Unique Users</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="avg-session">0m</div>
              <div class="stat-label">Avg. Session</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="completion-rate">0%</div>
              <div class="stat-label">Completion Rate</div>
            </div>
          </div>
        </div>

        <!-- Game Performance -->
        <div class="card">
          <div class="card-header">Game Performance</div>
          <div class="stat-container">
            <div class="stat-card">
              <div class="stat-value" id="win-rate">0%</div>
              <div class="stat-label">Win Rate</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="avg-attempts">0</div>
              <div class="stat-label">Avg. Attempts</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="give-up-rate">0%</div>
              <div class="stat-label">Give Up Rate</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="avg-time">0s</div>
              <div class="stat-label">Avg. Game Time</div>
            </div>
          </div>
        </div>

        <!-- Games Over Time Chart -->
        <div class="card">
          <div class="card-header">Games Played Over Time</div>
          <div class="chart-container">
            <canvas id="games-over-time"></canvas>
          </div>
        </div>

        <!-- Game Mode Preference -->
        <div class="card">
          <div class="card-header">Game Mode Preference</div>
          <div class="chart-container">
            <canvas id="mode-preference"></canvas>
          </div>
        </div>

        <!-- Language Distribution -->
        <div class="card">
          <div class="card-header">Language Distribution</div>
          <div class="chart-container">
            <canvas id="language-distribution"></canvas>
          </div>
        </div>

        <!-- Code Length Preference -->
        <div class="card">
          <div class="card-header">Code Length Preference</div>
          <div class="chart-container">
            <canvas id="length-preference"></canvas>
          </div>
        </div>

        <!-- Color Usage -->
        <div class="card">
          <div class="card-header">Color Usage</div>
          <div class="chart-container">
            <canvas id="color-usage"></canvas>
          </div>
        </div>

        <!-- Win Rate by Attempts -->
        <div class="card">
          <div class="card-header">Win Rate by Attempts</div>
          <div class="chart-container">
            <canvas id="win-by-attempts"></canvas>
          </div>
        </div>

        <!-- Recent Game Sessions -->
        <div class="card">
          <div class="card-header">Recent Game Sessions</div>
          <table id="recent-games">
            <thead>
              <tr>
                <th>Date</th>
                <th>Mode</th>
                <th>Result</th>
                <th>Attempts</th>
                <th>Duration</th>
              </tr>
            </thead>
            <tbody>
              <!-- Data will be inserted here dynamically -->
            </tbody>
          </table>
        </div>

        <!-- Device Distribution -->
        <div class="card">
          <div class="card-header">Device Distribution</div>
          <div class="chart-container">
            <canvas id="device-distribution"></canvas>
          </div>
        </div>
        
        <!-- Error Rates -->
        <div class="card">
          <div class="card-header">Error Rates</div>
          <div class="chart-container">
            <canvas id="error-rates"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="loading-overlay" class="loading-overlay">
    <div class="loading-spinner"></div>
  </div>

  <script>
    // Configuration - Update these values with your actual GA4 info
	const GA4_PROPERTY_ID = '486860865'; // Deine GA4 Property ID
	const GA4_CLIENT_ID = '82857070912-7n6f5ekb5161f02mupl5d1d7b5j3656f.apps.googleusercontent.com'; // Deine OAuth client ID (behalte diese)
	//const GA4_API_KEY = 'AIzaSyAf2h1mThchuKUO-MIMPweiV__KeqeJ1Co'; // Your API key
	const GA4_API_KEY = 'AIzaSyBNP0qJzO_f-7O2ZZ9MiS4vgiidzXxAvvs'; // Your API key
	
    
    // Define scope for Google Analytics API access
    const SCOPES = 'https://www.googleapis.com/auth/analytics.readonly';
    
    // Store chart instances for later reference
    const chartInstances = {};
    
    // Utility function to format numbers with commas
    function numberWithCommas(x) {
      return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
    
    // Utility function to format seconds into minutes and seconds
    function formatTime(seconds) {
      if (seconds < 60) return seconds + 's';
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return minutes + 'm ' + (remainingSeconds > 0 ? remainingSeconds + 's' : '');
    }
    
    // Display error message
    function showError(message) {
      const errorElement = document.getElementById('error-message');
      errorElement.textContent = message;
      errorElement.style.display = 'block';
      hideLoading();
    }
    
    // Display status message
    function showStatus(message) {
      const statusElement = document.getElementById('status-message');
      statusElement.textContent = message;
      statusElement.classList.remove('hidden');
      setTimeout(() => {
        statusElement.classList.add('hidden');
      }, 5000);
    }
    
    // Show loading overlay
    function showLoading() {
      document.getElementById('loading-overlay').style.display = 'flex';
    }
    
    // Hide loading overlay
    function hideLoading() {
      document.getElementById('loading-overlay').style.display = 'none';
    }
    
    // Initialize date inputs with default values (last 30 days)
    function initializeDateRange() {
      const today = new Date();
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(today.getDate() - 30);
      
      const formatDate = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };
      
      document.getElementById('start-date').value = formatDate(thirtyDaysAgo);
      document.getElementById('end-date').value = formatDate(today);
    }
    
    // Initialize charts with default empty data
    function initializeCharts() {
      // Games Over Time Chart
      const gamesOverTimeCtx = document.getElementById('games-over-time').getContext('2d');
      chartInstances.gamesOverTime = new Chart(gamesOverTimeCtx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [{
            label: 'Games',
            data: [],
            borderColor: '#6200EE',
            backgroundColor: 'rgba(98, 0, 238, 0.1)',
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                precision: 0
              }
            }
          }
        }
      });
      
      // Mode Preference Chart
      const modePreferenceCtx = document.getElementById('mode-preference').getContext('2d');
      chartInstances.modePreference = new Chart(modePreferenceCtx, {
        type: 'doughnut',
        data: {
          labels: ['2 Player', 'Computer as Breaker', 'Computer as Maker'],
          datasets: [{
            data: [0, 0, 0],
            backgroundColor: ['#4CAF50', '#2196F3', '#FF9800']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right'
            }
          }
        }
      });
      
      // Language Distribution Chart
      const languageCtx = document.getElementById('language-distribution').getContext('2d');
      chartInstances.languageDistribution = new Chart(languageCtx, {
        type: 'pie',
        data: {
          labels: ['English', 'German'],
          datasets: [{
            data: [0, 0],
            backgroundColor: ['#3F51B5', '#E91E63']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right'
            }
          }
        }
      });
      
      // Code Length Preference Chart
      const lengthCtx = document.getElementById('length-preference').getContext('2d');
      chartInstances.lengthPreference = new Chart(lengthCtx, {
        type: 'bar',
        data: {
          labels: ['4 Circles', '5 Circles'],
          datasets: [{
            label: 'Games',
            data: [0, 0],
            backgroundColor: '#9C27B0'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                precision: 0
              }
            }
          }
        }
      });
      
      // Color Usage Chart
      const colorCtx = document.getElementById('color-usage').getContext('2d');
      chartInstances.colorUsage = new Chart(colorCtx, {
        type: 'bar',
        data: {
          labels: ['Red', 'Yellow', 'Orange', 'Pink', 'Blue', 'Green', 'Gray', 'Black'],
          datasets: [{
            label: 'Usage Count',
            data: [0, 0, 0, 0, 0, 0, 0, 0],
            backgroundColor: [
              '#FF0000', '#FFFF00', '#FFC000', '#F36DED', 
              '#0070C0', '#00B050', '#A6A6A6', '#000000'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                precision: 0
              }
            }
          }
        }
      });
      
      // Win Rate by Attempts Chart
      const winByAttemptsCtx = document.getElementById('win-by-attempts').getContext('2d');
      chartInstances.winByAttempts = new Chart(winByAttemptsCtx, {
        type: 'line',
        data: {
          labels: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
          datasets: [{
            label: 'Win Rate',
            data: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
            borderColor: '#00BCD4',
            backgroundColor: 'rgba(0, 188, 212, 0.2)',
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              ticks: {
                callback: function(value) {
                  return value + '%';
                }
              }
            }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: function(context) {
                  return context.parsed.y + '%';
                }
              }
            }
          }
        }
      });
      
      // Device Distribution Chart
      const deviceCtx = document.getElementById('device-distribution').getContext('2d');
      chartInstances.deviceDistribution = new Chart(deviceCtx, {
        type: 'pie',
        data: {
          labels: ['Desktop', 'Mobile', 'Tablet'],
          datasets: [{
            data: [0, 0, 0],
            backgroundColor: ['#607D8B', '#FF5722', '#795548']
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right'
            }
          }
        }
      });
      
      // Error Rates Chart
      const errorCtx = document.getElementById('error-rates').getContext('2d');
      chartInstances.errorRates = new Chart(errorCtx, {
        type: 'bar',
        data: {
          labels: ['Game Logic', 'Network', 'Input', 'Rendering', 'Other'],
          datasets: [{
            label: 'Error Count',
            data: [0, 0, 0, 0, 0],
            backgroundColor: '#F44336'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              ticks: {
                precision: 0
              }
            }
          }
        }
      });
    }
    
    // Fetch analytics data
    async function fetchAnalyticsData() {
      try {
        showLoading();
        
        // Get date range values
        const startDate = document.getElementById('start-date').value || '30daysAgo';
        const endDate = document.getElementById('end-date').value || 'today';
        
        // Get filter values
        const modeFilter = document.getElementById('filter-mode').value;
        const codeLengthFilter = document.getElementById('filter-code-length').value;
        
        // Build filter string
        let filterString = 'ga:eventCategory==game';
        if (modeFilter !== 'all') {
          filterString += `;ga:eventLabel==${modeFilter}`;
        }
        if (codeLengthFilter !== 'all') {
          filterString += `;ga:eventLabel==${codeLengthFilter}`;
        }
        
        // Query for total games
        await queryTotalGames(startDate, endDate, filterString);
        
        // Query for unique users
        await queryUniqueUsers(startDate, endDate, filterString);
        
        // Query for session metrics
        await querySessionMetrics(startDate, endDate, filterString);
        
        // Query for game performance
        await queryGamePerformance(startDate, endDate, filterString);
        
        // Query for games over time
        await queryGamesOverTime(startDate, endDate, filterString);
        
        // Query for mode preference
        await queryModePreference(startDate, endDate);
        
        // Query for language distribution
        await queryLanguageDistribution(startDate, endDate);
        
        // Query for code length preference
        await queryCodeLengthPreference(startDate, endDate);
        
        // Query for color usage
        await queryColorUsage(startDate, endDate);
        
        // Query for win rate by attempts
        await queryWinRateByAttempts(startDate, endDate);
        
        // Query for recent game sessions
        await queryRecentSessions(startDate, endDate);
        
        // Query for device distribution
        await queryDeviceDistribution(startDate, endDate);
        
        // Query for error rates
        await queryErrorRates(startDate, endDate);
        
        showStatus('Analytics data updated successfully');
        hideLoading();
      } catch (error) {
        console.error('Error fetching analytics data:', error);
        showError('Failed to fetch analytics data. Error: ' + error.message);
      }
	  // For now, use demo data until we integrate the actual GA4 API calls
	loadDemoData();
	showStatus('Analytics data updated (demo mode)');
	return;
    }
    
    // Query for total games
    async function queryTotalGames(startDate, endDate, filterString) {
      const totalGamesQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:eventCategory',
          'filters': 'ga:eventCategory==game;ga:eventAction==start'
        }
      });
      
      const response = await totalGamesQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      let totalGames = 0;
      if (response.rows && response.rows.length > 0) {
        totalGames = parseInt(response.rows[0][1]);
      }
      
      document.getElementById('total-games').textContent = numberWithCommas(totalGames);
    }
    
    // Query for unique users
    async function queryUniqueUsers(startDate, endDate, filterString) {
      const uniqueUsersQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:users',
          'filters': 'ga:eventCategory==game'
        }
      });
      
      const response = await uniqueUsersQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      let totalUsers = 0;
      if (response.rows && response.rows.length > 0) {
        totalUsers = parseInt(response.rows[0][0]);
      }
      
      document.getElementById('total-users').textContent = numberWithCommas(totalUsers);
    }
    
    // Query for session metrics
    async function querySessionMetrics(startDate, endDate, filterString) {
      const sessionQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:avgSessionDuration,ga:sessionCount,ga:bounceRate'
        }
      });
      
      const response = await sessionQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      if (response.rows && response.rows.length > 0) {
        const avgSessionDuration = Math.round(parseFloat(response.rows[0][0]));
        const completionRate = 100 - parseFloat(response.rows[0][2]);
        
        document.getElementById('avg-session').textContent = formatTime(avgSessionDuration);
        document.getElementById('completion-rate').textContent = completionRate.toFixed(1) + '%';
      }
    }
    
    // Query for game performance
    async function queryGamePerformance(startDate, endDate, filterString) {
      const performanceQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:eventAction',
          'filters': 'ga:eventCategory==game;ga:eventAction==end'
        }
      });
      
      const response = await performanceQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      // Get win/loss data by querying event labels
      const resultQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:eventLabel',
          'filters': 'ga:eventCategory==game;ga:eventAction==end'
        }
      });
      
      const resultResponse = await resultQuery.execute();
      
      if (resultResponse.error) {
        throw new Error(resultResponse.error.message);
      }
      
      let wins = 0;
      let giveUps = 0;
      let totalGames = 0;
      let totalAttempts = 0;
      let totalDuration = 0;
      
      if (resultResponse.rows && resultResponse.rows.length > 0) {
        for (const row of resultResponse.rows) {
          const label = row[0];
          const count = parseInt(row[1]);
          
          totalGames += count;
          
          if (label.includes('win')) {
            wins += count;
          } else if (label.includes('giveUp=true') || label.includes('abandoned')) {
            giveUps += count;
          }
          
          // Extract attempts and duration from labels if available
          const attemptsMatch = label.match(/attempts=(\d+)/);
          const durationMatch = label.match(/duration=(\d+)/);
          
          if (attemptsMatch) {
            totalAttempts += parseInt(attemptsMatch[1]) * count;
          }
          
          if (durationMatch) {
            totalDuration += parseInt(durationMatch[1]) * count;
          }
        }
      }
      
      // Calculate metrics
      const winRate = totalGames > 0 ? (wins / totalGames) * 100 : 0;
      const giveUpRate = totalGames > 0 ? (giveUps / totalGames) * 100 : 0;
      const avgAttempts = totalGames > 0 ? totalAttempts / totalGames : 0;
      const avgTime = totalGames > 0 ? totalDuration / totalGames : 0;
      
      // Update UI
      document.getElementById('win-rate').textContent = winRate.toFixed(1) + '%';
      document.getElementById('give-up-rate').textContent = giveUpRate.toFixed(1) + '%';
      document.getElementById('avg-attempts').textContent = avgAttempts.toFixed(1);
      document.getElementById('avg-time').textContent = formatTime(Math.round(avgTime));
    }
    
    // Query for games over time
    async function queryGamesOverTime(startDate, endDate, filterString) {
      const gamesOverTimeQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:date',
          'filters': 'ga:eventCategory==game;ga:eventAction==start',
          'sort': 'ga:date'
        }
      });
      
      const response = await gamesOverTimeQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      const labels = [];
      const data = [];
      
      if (response.rows && response.rows.length > 0) {
        response.rows.forEach(row => {
          // Format the date from YYYYMMDD to MM/DD
          const dateStr = row[0];
          const month = dateStr.substr(4, 2);
          const day = dateStr.substr(6, 2);
          const formattedDate = `${month}/${day}`;
          
          labels.push(formattedDate);
          data.push(parseInt(row[1]));
        });
      }
      
      // Update the chart
      chartInstances.gamesOverTime.data.labels = labels;
      chartInstances.gamesOverTime.data.datasets[0].data = data;
      chartInstances.gamesOverTime.update();
    }
    
    // Query for mode preference
    async function queryModePreference(startDate, endDate) {
      const modePreferenceQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:eventLabel',
          'filters': 'ga:eventCategory==game;ga:eventAction==start;ga:eventLabel=~mode=',
        }
      });
      
      const response = await modePreferenceQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      let bothCount = 0;
      let codemakerCount = 0;
      let codebreakerCount = 0;
      
      if (response.rows && response.rows.length > 0) {
        for (const row of response.rows) {
          const label = row[0];
          const count = parseInt(row[1]);
          
          if (label.includes('mode=both')) {
            bothCount += count;
          } else if (label.includes('mode=codemakerMode')) {
            codemakerCount += count;
          } else if (label.includes('mode=codebreakerMode')) {
            codebreakerCount += count;
          }
        }
      }
      
      // Update the chart
      chartInstances.modePreference.data.datasets[0].data = [bothCount, codemakerCount, codebreakerCount];
      chartInstances.modePreference.update();
    }
    
    // Query for language distribution
    async function queryLanguageDistribution(startDate, endDate) {
      const languageQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:eventLabel',
          'filters': 'ga:eventCategory==game;ga:eventAction==start;ga:eventLabel=~language=',
        }
      });
      
      const response = await languageQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      let englishCount = 0;
      let germanCount = 0;
      
      if (response.rows && response.rows.length > 0) {
        for (const row of response.rows) {
          const label = row[0];
          const count = parseInt(row[1]);
          
          if (label.includes('language=en')) {
            englishCount += count;
          } else if (label.includes('language=de')) {
            germanCount += count;
          }
        }
      }
      
      // Update the chart
      chartInstances.languageDistribution.data.datasets[0].data = [englishCount, germanCount];
      chartInstances.languageDistribution.update();
    }
    
    // Query for code length preference
    async function queryCodeLengthPreference(startDate, endDate) {
      const codeLengthQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:eventLabel',
          'filters': 'ga:eventCategory==game;ga:eventAction==start;ga:eventLabel=~codeLength=',
        }
      });
      
      const response = await codeLengthQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      let fourCodeCount = 0;
      let fiveCodeCount = 0;
      
      if (response.rows && response.rows.length > 0) {
        for (const row of response.rows) {
          const label = row[0];
          const count = parseInt(row[1]);
          
          if (label.includes('codeLength=4')) {
            fourCodeCount += count;
          } else if (label.includes('codeLength=5')) {
            fiveCodeCount += count;
          }
        }
      }
      
      // Update the chart
      chartInstances.lengthPreference.data.datasets[0].data = [fourCodeCount, fiveCodeCount];
      chartInstances.lengthPreference.update();
    }
    
    // Query for color usage
    async function queryColorUsage(startDate, endDate) {
      const colorUsageQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:eventLabel',
          'filters': 'ga:eventCategory==interaction;ga:eventAction==color_select',
        }
      });
      
      const response = await colorUsageQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      const colorCounts = [0, 0, 0, 0, 0, 0, 0, 0]; // Red, Yellow, Orange, Pink, Blue, Green, Gray, Black
      
      if (response.rows && response.rows.length > 0) {
        for (const row of response.rows) {
          const label = row[0];
          const count = parseInt(row[1]);
          
          // Parse color from event label
          if (label.includes('color=#FF0000')) colorCounts[0] += count; // Red
          else if (label.includes('color=#FFFF00')) colorCounts[1] += count; // Yellow
          else if (label.includes('color=#FFC000')) colorCounts[2] += count; // Orange
          else if (label.includes('color=#F36DED')) colorCounts[3] += count; // Pink
          else if (label.includes('color=#0070C0')) colorCounts[4] += count; // Blue
          else if (label.includes('color=#00B050')) colorCounts[5] += count; // Green
          else if (label.includes('color=#A6A6A6')) colorCounts[6] += count; // Gray
          else if (label.includes('color=#000000')) colorCounts[7] += count; // Black
        }
      }
      
      // Update the chart
      chartInstances.colorUsage.data.datasets[0].data = colorCounts;
      chartInstances.colorUsage.update();
    }
    
    // Query for win rate by attempts
    async function queryWinRateByAttempts(startDate, endDate) {
      const winRateQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:eventLabel',
          'filters': 'ga:eventCategory==game;ga:eventAction==end;ga:eventLabel=~attempts=',
        }
      });
      
      const response = await winRateQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      // Initialize arrays to store attempts data
      const winsByAttempt = Array(10).fill(0);
      const totalByAttempt = Array(10).fill(0);
      
      if (response.rows && response.rows.length > 0) {
        for (const row of response.rows) {
          const label = row[0];
          const count = parseInt(row[1]);
          
          // Extract attempts number
          const attemptsMatch = label.match(/attempts=(\d+)/);
          if (attemptsMatch) {
            const attempts = parseInt(attemptsMatch[1]);
            if (attempts > 0 && attempts <= 10) {
              totalByAttempt[attempts - 1] += count;
              
              // Check if this was a win
              if (label.includes('result=win')) {
                winsByAttempt[attempts - 1] += count;
              }
            }
          }
        }
      }
      
      // Calculate win rates for each attempt count
      const winRates = winsByAttempt.map((wins, i) => 
        totalByAttempt[i] > 0 ? (wins / totalByAttempt[i]) * 100 : 0
      );
      
      // Update the chart
      chartInstances.winByAttempts.data.datasets[0].data = winRates;
      chartInstances.winByAttempts.update();
    }
    
    // Query for recent game sessions
    async function queryRecentSessions(startDate, endDate) {
      const recentGamesQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:date,ga:eventLabel',
          'filters': 'ga:eventCategory==game;ga:eventAction==end',
          'sort': '-ga:date',
          'max-results': 20
        }
      });
      
      const response = await recentGamesQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      const tableBody = document.querySelector('#recent-games tbody');
      tableBody.innerHTML = ''; // Clear existing rows
      
      if (response.rows && response.rows.length > 0) {
        for (const row of response.rows) {
          const date = row[0]; // YYYYMMDD format
          const label = row[1];
          
          // Format date as MM/DD/YYYY
          const formattedDate = `${date.substr(4, 2)}/${date.substr(6, 2)}/${date.substr(0, 4)}`;
          
          // Extract game data from label
          let mode = 'Unknown';
          if (label.includes('mode=both')) mode = '2 Player';
          else if (label.includes('mode=codemakerMode')) mode = 'Computer as Breaker';
          else if (label.includes('mode=codebreakerMode')) mode = 'Computer as Maker';
          
          let result = 'Unknown';
          if (label.includes('result=win')) result = 'Win';
          else if (label.includes('result=loss')) result = 'Loss';
          else if (label.includes('result=abandoned')) result = 'Abandoned';
          
          let attempts = '-';
          const attemptsMatch = label.match(/attempts=(\d+)/);
          if (attemptsMatch) attempts = attemptsMatch[1];
          
          let duration = '-';
          const durationMatch = label.match(/duration=(\d+)/);
          if (durationMatch) duration = formatTime(parseInt(durationMatch[1]));
          
          // Create table row
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${formattedDate}</td>
            <td>${mode}</td>
            <td>${result}</td>
            <td>${attempts}</td>
            <td>${duration}</td>
          `;
          
          tableBody.appendChild(tr);
        }
      }
      
      // Add empty row if no data
      if (tableBody.children.length === 0) {
        const tr = document.createElement('tr');
        tr.innerHTML = '<td colspan="5" style="text-align: center;">No recent games found</td>';
        tableBody.appendChild(tr);
      }
    }
    
    // Query for device distribution
    async function queryDeviceDistribution(startDate, endDate) {
      const deviceQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:sessions',
          'dimensions': 'ga:deviceCategory'
        }
      });
      
      const response = await deviceQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      let desktopCount = 0;
      let mobileCount = 0;
      let tabletCount = 0;
      
      if (response.rows && response.rows.length > 0) {
        for (const row of response.rows) {
          const deviceType = row[0];
          const count = parseInt(row[1]);
          
          if (deviceType === 'desktop') {
            desktopCount = count;
          } else if (deviceType === 'mobile') {
            mobileCount = count;
          } else if (deviceType === 'tablet') {
            tabletCount = count;
          }
        }
      }
      
      // Update the chart
      chartInstances.deviceDistribution.data.datasets[0].data = [desktopCount, mobileCount, tabletCount];
      chartInstances.deviceDistribution.update();
    }
    
    // Query for error rates
    async function queryErrorRates(startDate, endDate) {
      const errorQuery = new gapi.analytics.report.Data({
        query: {
          'ids': `ga:${GA_PROPERTY_ID}`,
          'start-date': startDate,
          'end-date': endDate,
          'metrics': 'ga:totalEvents',
          'dimensions': 'ga:eventAction',
          'filters': 'ga:eventCategory==error'
        }
      });
      
      const response = await errorQuery.execute();
      
      if (response.error) {
        throw new Error(response.error.message);
      }
      
      const errorCounts = [0, 0, 0, 0, 0]; // Game Logic, Network, Input, Rendering, Other
      
      if (response.rows && response.rows.length > 0) {
        for (const row of response.rows) {
          const errorType = row[0];
          const count = parseInt(row[1]);
          
          if (errorType.includes('javascript')) {
            errorCounts[0] += count; // Game Logic
          } else if (errorType.includes('network')) {
            errorCounts[1] += count; // Network
          } else if (errorType.includes('input')) {
            errorCounts[2] += count; // Input
          } else if (errorType.includes('rendering')) {
            errorCounts[3] += count; // Rendering
          } else {
            errorCounts[4] += count; // Other
          }
        }
      }
      
      // Update the chart
      chartInstances.errorRates.data.datasets[0].data = errorCounts;
      chartInstances.errorRates.update();
    }
    
    // Export data to CSV
    async function exportDataToCSV() {
      showLoading();
      
      // Collect all current data
      const exportData = {
        overview: {
          'Total Games': document.getElementById('total-games').textContent,
          'Unique Users': document.getElementById('total-users').textContent,
          'Average Session Duration': document.getElementById('avg-session').textContent,
          'Completion Rate': document.getElementById('completion-rate').textContent
        },
        performance: {
          'Win Rate': document.getElementById('win-rate').textContent,
          'Average Attempts': document.getElementById('avg-attempts').textContent,
          'Give Up Rate': document.getElementById('give-up-rate').textContent,
          'Average Game Time': document.getElementById('avg-time').textContent
        }
      };
      
      // Create CSV content
      let csvContent = 'data:text/csv;charset=utf-8,';
      
      // Add overview section
      csvContent += 'OVERVIEW\r\n';
      csvContent += 'Metric,Value\r\n';
      for (const [key, value] of Object.entries(exportData.overview)) {
        csvContent += `${key},${value}\r\n`;
      }
      csvContent += '\r\n';
      
      // Add performance section
      csvContent += 'PERFORMANCE\r\n';
      csvContent += 'Metric,Value\r\n';
      for (const [key, value] of Object.entries(exportData.performance)) {
        csvContent += `${key},${value}\r\n`;
      }
      csvContent += '\r\n';
      
      // Add games over time
      if (chartInstances.gamesOverTime.data.labels.length > 0) {
        csvContent += 'GAMES OVER TIME\r\n';
        csvContent += 'Date,Games\r\n';
        chartInstances.gamesOverTime.data.labels.forEach((label, i) => {
          csvContent += `${label},${chartInstances.gamesOverTime.data.datasets[0].data[i]}\r\n`;
        });
        csvContent += '\r\n';
      }
      
      // Add mode preference
      csvContent += 'MODE PREFERENCE\r\n';
      csvContent += 'Mode,Count\r\n';
      chartInstances.modePreference.data.labels.forEach((label, i) => {
        csvContent += `${label},${chartInstances.modePreference.data.datasets[0].data[i]}\r\n`;
      });
      csvContent += '\r\n';
      
      // Add language distribution
      csvContent += 'LANGUAGE DISTRIBUTION\r\n';
      csvContent += 'Language,Count\r\n';
      chartInstances.languageDistribution.data.labels.forEach((label, i) => {
        csvContent += `${label},${chartInstances.languageDistribution.data.datasets[0].data[i]}\r\n`;
      });
      csvContent += '\r\n';
      
      // Create a download link and trigger click
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement('a');
      link.setAttribute('href', encodedUri);
      link.setAttribute('download', 'mastermind_analytics.csv');
      document.body.appendChild(link);
      
      link.click();
      document.body.removeChild(link);
      
      hideLoading();
      showStatus('Data exported successfully');
    }
    
	// Initialize Google API client and authenticate
	async function initializeGoogleAnalytics() {
	  try {
		showLoading();
		
		// Load the API client
		await new Promise((resolve, reject) => {
		  gapi.load('client:auth2', {
			callback: resolve,
			onerror: reject
		  });
		});
		
		// Initialize the client with API key
		await gapi.client.init({
		  apiKey: GA4_API_KEY,
		  clientId: GA4_CLIENT_ID,
		  discoveryDocs: ['https://analyticsdata.googleapis.com/$discovery/rest?version=v1beta'],
		  scope: SCOPES
		});
		
		// Show sign in button
		document.getElementById('sign-in-button').classList.remove('hidden');
		
		// Setup Sign In button
		document.getElementById('sign-in-button').addEventListener('click', () => {
		  gapi.auth2.getAuthInstance().signIn().then(
			() => {
			  onSignInSuccess();
			},
			(error) => {
			  showError('Sign in error: ' + error.error);
			}
		  );
		});
		
		// Setup Sign Out button
		document.getElementById('sign-out-button').addEventListener('click', () => {
		  gapi.auth2.getAuthInstance().signOut().then(() => {
			document.getElementById('dashboard-content').classList.add('hidden');
			document.getElementById('sign-in-button').classList.remove('hidden');
			document.getElementById('sign-out-button').classList.add('hidden');
			showStatus('Signed out successfully');
		  });
		});
		
		// Check if user already signed in
		if (gapi.auth2.getAuthInstance().isSignedIn.get()) {
		  onSignInSuccess();
		} else {
		  hideLoading();
		}
		
	  } catch (error) {
		console.error('Google API initialization error:', error);
		showError('Failed to initialize Google API: ' + error.message);
		hideLoading();
	  }
	}

	// Handle successful sign-in
	function onSignInSuccess() {
	  document.getElementById('dashboard-content').classList.remove('hidden');
	  document.getElementById('sign-in-button').classList.add('hidden');
	  document.getElementById('sign-out-button').classList.remove('hidden');
	  
	  initializeDateRange();
	  initializeCharts();
	  
	  // Load demo data for now (will replace with actual API calls)
	  loadDemoData();
	  
	  // Add event listeners for interactive elements
	  document.getElementById('apply-date').addEventListener('click', fetchAnalyticsData);
	  document.getElementById('refresh-data').addEventListener('click', fetchAnalyticsData);
	  document.getElementById('export-data').addEventListener('click', exportDataToCSV);
	  document.getElementById('filter-mode').addEventListener('change', fetchAnalyticsData);
	  document.getElementById('filter-code-length').addEventListener('change', fetchAnalyticsData);
	}

	// Load demo data for initial display
	function loadDemoData() {
	  // Set overview statistics
	  document.getElementById('total-games').textContent = '1,250';
	  document.getElementById('total-users').textContent = '450';
	  document.getElementById('avg-session').textContent = '5m 30s';
	  document.getElementById('completion-rate').textContent = '85.7%';
	  
	  // Set game performance statistics
	  document.getElementById('win-rate').textContent = '62.5%';
	  document.getElementById('avg-attempts').textContent = '5.8';
	  document.getElementById('give-up-rate').textContent = '18.3%';
	  document.getElementById('avg-time').textContent = '3m 45s';
	  
	  // Update time series chart
	  const timeLabels = [];
	  const timeData = [];
	  const today = new Date();
	  
	  for (let i = 30; i > 0; i--) {
		const date = new Date();
		date.setDate(today.getDate() - i);
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const day = String(date.getDate()).padStart(2, '0');
		timeLabels.push(`${month}/${day}`);
		timeData.push(Math.floor(Math.random() * 45) + 5);
	  }
	  
	  chartInstances.gamesOverTime.data.labels = timeLabels;
	  chartInstances.gamesOverTime.data.datasets[0].data = timeData;
	  chartInstances.gamesOverTime.update();
	  
	  // Update mode preference chart
	  chartInstances.modePreference.data.datasets[0].data = [45, 30, 25];
	  chartInstances.modePreference.update();
	  
	  // Update language distribution chart
	  chartInstances.languageDistribution.data.datasets[0].data = [70, 30];
	  chartInstances.languageDistribution.update();
	  
	  // Update code length preference chart
	  chartInstances.lengthPreference.data.datasets[0].data = [65, 35];
	  chartInstances.lengthPreference.update();
	  
	  // Update color usage chart
	  chartInstances.colorUsage.data.datasets[0].data = [120, 95, 85, 75, 110, 90, 60, 70];
	  chartInstances.colorUsage.update();
	  
	  // Update win rate by attempts chart
	  chartInstances.winByAttempts.data.datasets[0].data = [90, 75, 65, 50, 40, 30, 25, 20, 15, 10];
	  chartInstances.winByAttempts.update();
	  
	  // Update device distribution chart
	  chartInstances.deviceDistribution.data.datasets[0].data = [55, 35, 10];
	  chartInstances.deviceDistribution.update();
	  
	  // Update error rates chart
	  chartInstances.errorRates.data.datasets[0].data = [12, 8, 5, 3, 4];
	  chartInstances.errorRates.update();
	  
	  // Update recent games table
	  const sampleGames = [
		{ date: '04/20/2025', mode: '2 Player', result: 'Win', attempts: 5, duration: '2m 45s' },
		{ date: '04/19/2025', mode: 'Computer as Maker', result: 'Win', attempts: 7, duration: '4m 12s' },
		{ date: '04/19/2025', mode: '2 Player', result: 'Loss', attempts: 10, duration: '5m 30s' },
		{ date: '04/18/2025', mode: 'Computer as Breaker', result: 'Win', attempts: 4, duration: '2m 15s' },
		{ date: '04/17/2025', mode: 'Computer as Maker', result: 'Abandoned', attempts: 3, duration: '1m 45s' },
		{ date: '04/16/2025', mode: '2 Player', result: 'Win', attempts: 6, duration: '3m 10s' },
		{ date: '04/15/2025', mode: 'Computer as Breaker', result: 'Loss', attempts: 10, duration: '6m 05s' },
		{ date: '04/15/2025', mode: 'Computer as Maker', result: 'Win', attempts: 5, duration: '3m 30s' },
		{ date: '04/14/2025', mode: '2 Player', result: 'Win', attempts: 3, duration: '1m 50s' },
		{ date: '04/13/2025', mode: 'Computer as Breaker', result: 'Win', attempts: 8, duration: '4m 40s' }
	  ];
	  
	  const tableBody = document.querySelector('#recent-games tbody');
	  tableBody.innerHTML = ''; // Clear existing rows
	  
	  for (const game of sampleGames) {
		const tr = document.createElement('tr');
		tr.innerHTML = `
		  <td>${game.date}</td>
		  <td>${game.mode}</td>
		  <td>${game.result}</td>
		  <td>${game.attempts}</td>
		  <td>${game.duration}</td>
		`;
		
		tableBody.appendChild(tr);
	  }
	}
    
    // Initialize the application
    function init() {
      try {
        showLoading();
        initializeGoogleAnalytics();
      } catch (error) {
        console.error('Initialization error:', error);
        showError('Failed to initialize application: ' + error.message);
      }
    }
    
    // Start the application when the page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>